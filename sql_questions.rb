In our Property Tracker application:

Q1. Where are we instantiating instances of the Property class?

console.rb file.

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?

Property class file.

Q3. In console.rb, which lines modify the database?

console.rb does not modify the database unless a method/function etc .update is defined in the Property class file.

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?

'id' is not a key with a value that we create. It is generated as we add information to our database.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?

  Within the sql syntax in the defined function/method we can prompt the database to return the id of the information we've saved into out database.

Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?
  To avoid getting a nil when returning the id value.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?

Some functions target a single object while when a method is defined through a class, it targets the class as a whole.

Q8. What type of data structure is returned by calls to db.exec_prepared()? In the save method, how do we access the id from the returned data structure?

SQL's version of an array of hashes, pulling from the 0 index of the array and pulling from the 'id' key within the hashes.

Q9. Why do we use prepared statements when performing database operations?

  To avoid SQL injection attacks.
